# <center>Документация

## Список функций

[concatenate](#strt-concatenatestrt-str1-strt-str2) - конкатенация строк.

[replace](#strt-replacestrt-str-const-char-pattern-const-char-replace) - замена шаблона символом

[replace_str](#strt-replacestrstrt-str-const-char-pattern-strt-replace) - замена шаблона строкой

[index_str](#int64t-indexstrstrt-string-strt-substring) - поиск первого вхождения подстроки

[get_str](#strt-getstr) - считывания строки из консоли

[get_fstr](#strt-getfstrfile-stream) - считывания строки из файла

[check_str_in](#bool-checkstrinstrt-string-strt-substring) - проверка вхождения подстроки в строку

[upper](#strt-upperstrt-str) - преобразование строки к верхнему регистру

[lower](#strt-lowerstrt-str) - преобразование строки к нижнему регистру

[split](#strt-splitstrt-str-const-char-separator) - разделение строки по разделителю

[isdigit](#bool-isdigitstrt-str) - проверяет состоит ли строка из цифр

[isalpha](#bool-isalphastrt-str) - проверяет состоит ли строка из букв

[equals](#bool-equalsstrt-str1-strt-str2) - посимвольное сравнение строк

[multi_str](#strt-multistrstrt-str-uint32t-num) - умножение строки на число

[stfree](#void-stfreestrt-str) - очистка памяти для строки

[from_cstr](#strt-fromcstrchar-str) - приведение строки типа char* к str_t

[f_str](#strt-fstrchar-str) - функция f-строк

## Функции

------------------------------------
### str_t concatenate(str_t str1, str_t str2)
------------------------------------

Функция конкатенации строк

Аргументы:

- **str_t** str1 - исходная строка, к ней надо присобачить вторую строку.
- **str_t** str2 - строка которую складывают к первой строке

Возвращает:

- **str_t** str1

Пример:

```bash
>>> str_t str1 = "Привет ";
>>> str = concatenate(str1, "мир.");
>>> str1
Привет мир.
```

------------------------------------
### str_t replace(str_t str, const char* pattern, const char* replace)
------------------------------------

Функция замены шаблона символом

Аргументы:

- **str_t** str - изменяемая строка
- **const char*** pattern - шаблон, который нужно заменить
- **const char*** replacement - строка, на которую заменяют шаблон

Возвращает:

- **str_t** str

Пример:

```bash
>>> str_t str = "Привет ";
>>> str = replace(str, ' ', '!');
>>> str
Привет!
```

------------------------------------
### str_t replace_str(str_t str, const char* pattern, str_t replace)
------------------------------------

Функция замены шаблона строкой

Аргументы:

- **str_t** str - изменяемая строка
- **const char*** pattern - шаблон, который нужно заменить
- **str_t** replacement - строка, на которую заменяют шаблон

Возвращает:

- **str_t** str

Пример:

```bash
>>> str_t str = "Привет ";
>>> str = replace_str(str, ' ', "!");
>>> str
Привет!
```

------------------------------------
### int64_t index_str(str_t string, str_t substring)
------------------------------------

Функция поиска первого вхождения подстроки

Аргументы:

- **str_t** string - строка, в которой осуществляется поиск
- **str_t** substring - искомая строка

Возвращает:

- **int64_t** result - индекс первого вхождения подстроки в строку

Пример:

```bash
>>> index_str("Привет мир", "ив");
2
```

------------------------------------
### str_t get_str( )
------------------------------------

Функция считывания строки из консоли

Возвращает:

- **str_t** str - строку, введённую пользователем

------------------------------------
### str_t get_fstr(FILE* stream)
------------------------------------

Функция считывания строки из файла

Аргументы:

- **FILE*** stream - поток, из которого считывается строка

Возвращает:

- **str_t** str - строку, считанную из файла

```bash
>>> get_fstr(FILE* stream);
```

------------------------------------
### bool check_str_in(str_t string, str_t substring)
------------------------------------

Проверяет, входит ли подстрока в строку

Аргументы:

- **str_t** string - строка в которой ищется подстрока
- **str_t** substring - подстрока

Возвращает:

- **bool** true/1 - если подстрока входит в строку
- **bool** false/0 - если не входит

```bash
check_str_in(str_t string, str_t substring);
```

------------------------------------
### str_t upper(str_t str)
------------------------------------

Преобразование строки к верхнему регистру

Аргументы:

- **str_t** str - строка, которую необходимо преобразовать

Возвращает:

- **str_t** str - изменённую строку

```bash
upper(str_t str);
```

------------------------------------
### str_t lower(str_t str)
------------------------------------

Преобразование строки к нижнему регистру

Аргументы:

- **str_t** str - строка, которую необходимо преобразовать

Возвращает:

- **str_t** str - изменённую строку

```bash
lower(str_t str);
```

------------------------------------
### str_t* split(str_t str, const char* separator)
------------------------------------

Разделяет строку по разделителю

Аргументы:

- str - исходная строка
- separator - строка-разделитель

Возвращает:

- указатель на массив строк

```bash
split(str_t str, const char* separator);
```

------------------------------------
### bool isdigit(str_t str)
------------------------------------

Проверяет состоит ли строка из цифр

Аргументы:

- **str_t** str - проверяемая строка

Возвращает:

- **bool** true/1 - если строка состоит из цифр
- **bool** false/0 - если не состоит

```bash
isdigit(str_t str);
```

------------------------------------
### bool isalpha(str_t str)
------------------------------------

Проверяет состоит ли строка из букв

Аргументы:

- str - проверяемая строка

Возвращает:

- **bool** true/1 - если строка состоит из букв
- **bool** false/0 - если не состоит

Пример:

```bash
>>> isalpha("Строка");
1
>>> isalpha("1 символ");
0
```

------------------------------------
### bool equals(str_t str1, str_t str2)
------------------------------------

Посимвольное сравнение строк

Аргументы:

- **str_t** str1 - строка для сравнения
- **str_t** str2 - строка для сравнения

Возвращает:

- **bool** true/1 - если строки эквивалентны
- **bool** false/0 - если не эквивалентны

```bash
equals(str1, str2);
```

------------------------------------
### str_t multi_str(str_t str, uint32_t num)
------------------------------------

------------------------------------
### void stfree(str_t str)
------------------------------------

------------------------------------
### str_t from_cstr(char *str)
------------------------------------

------------------------------------
### str_t f_str(char *str)
------------------------------------
